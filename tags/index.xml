<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>@uyorumの雑記帳</title>
    <link>http://uyorum.github.io/tags/</link>
    <description>Recent content on @uyorumの雑記帳</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>uyorum All Right Reserved.</copyright>
    <lastBuildDate>Sun, 18 Jun 2017 16:56:40 +0900</lastBuildDate>
    
	<atom:link href="http://uyorum.github.io/tags/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>スマートボトルの選定</title>
      <link>http://uyorum.github.io/blog/choosing-smart-water-bottle/</link>
      <pubDate>Sun, 18 Jun 2017 16:56:40 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/choosing-smart-water-bottle/</guid>
      <description>&lt;p&gt;現在使っている水筒(ケータイマグ 600ml)が古くなってきて，新しいものに変えたい．最近Fitbitで水分補給量も記録するようになったが手動入力が面倒なのでこれを自動でやってくれる水筒を選定した&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>スマートボトルの選定</title>
      <link>http://uyorum.github.io/blog/choosing-smart-water-bottle/</link>
      <pubDate>Sun, 18 Jun 2017 16:56:40 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/choosing-smart-water-bottle/</guid>
      <description>&lt;p&gt;現在使っている水筒(ケータイマグ 600ml)が古くなってきて，新しいものに変えたい．最近Fitbitで水分補給量も記録するようになったが手動入力が面倒なのでこれを自動でやってくれる水筒を選定した&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Infrastructure as Code 感想 (4章)</title>
      <link>http://uyorum.github.io/blog/infrastructure-as-code-chap4/</link>
      <pubDate>Sat, 17 Jun 2017 18:17:36 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/infrastructure-as-code-chap4/</guid>
      <description>&lt;p&gt;オライリーの「Infrastructure as Code」を読んで思ったことや自分的メモをまとめておく．&lt;strong&gt;太字は自分の感想&lt;/strong&gt;， &lt;em&gt;斜字体は本からの引用&lt;/em&gt; ，そのほかは本の要約など．&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Infrastructure as Code 感想 (4章)</title>
      <link>http://uyorum.github.io/blog/infrastructure-as-code-chap4/</link>
      <pubDate>Sat, 17 Jun 2017 18:17:36 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/infrastructure-as-code-chap4/</guid>
      <description>&lt;p&gt;オライリーの「Infrastructure as Code」を読んで思ったことや自分的メモをまとめておく．&lt;strong&gt;太字は自分の感想&lt;/strong&gt;， &lt;em&gt;斜字体は本からの引用&lt;/em&gt; ，そのほかは本の要約など．&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Infrastructure as Code 感想 (3章)</title>
      <link>http://uyorum.github.io/blog/infrastructure-as-code-chap3/</link>
      <pubDate>Thu, 15 Jun 2017 23:14:55 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/infrastructure-as-code-chap3/</guid>
      <description>オライリーの「Infrastructure as Code」を読んで思ったことや自分的メモをまとめておく．太字は自分の感想， 斜字体は本からの引用 ，そのほかは本の要約など．
ツールの要件  他のツールを連携しやすいこと  コマンドライン引数や環境変数などでの入力，パースしやすい結果出力 設定の外在化  自動実行しやすいこと  冪等性など 失敗したらわかる  周辺のツールとの連携しやすさは意識して考慮に入れてなかった 考え方はすごくよくわかる．UNIX哲学に通じている  構成レジストリ  コンフィグ定義ツールが提供するもの(Chef Server, Ansible Towerなど) Zookeeper/Consul/etcd プログラムによるレジストリエントリの追加，更新，削除をサポートしていること こういうのほしいと前から思っていたけどどうやって実装すればいいか，定義ツールとどう連携させればいいかイメージついてない  軽い構成レジストリ  S3やVCS上のファイル  HTTP等で配布．こうすることで可用性，スケーリングしやすい．管理が単純 頻繁に更新されて複雑になる部分は分割やシャーディングで対応する  こうした場合，例えばAnsibleへはどうやって渡せばいいんだろうか  ansible-playbook実行前にyaml組んでvar_fileなどに渡す  ダイナミックインベントリみたいなことはできなさそう．一回ファイルに吐き出す必要がある？  json組み立ててansible-playbookの--extra-varsオプションに渡す Ansible TowerのAPIでも渡せるかも  Consumer Driven Contract Testing  Itamaeのnode.validate!はまさにこれだと思う1 こんな記事出てきた Consumer-Driven Contracts: A Service Evolution Pattern Pactのようなツールで容易に書けそう   CMDB  CMDBとInfrastructure as Codeは構成管理に対するアプローチが正反対．両者を同一視してはならない  ただしすべてを自動化するならInfrastructure as CodeはCMDBを兼ねることができる．またはInfrastructure as CodeがCMDBも管理することができる ハードウェアも含めてすべてを自動化はけっこうハードル高そう   その他  インフラを完全に管理，自動化するために，やり方を変えるだけでなく自動化しやすいようにタスクそのものを見直すメンタルを忘れてはいけない  以上</description>
    </item>
    
    <item>
      <title>Infrastructure as Code 感想 (3章)</title>
      <link>http://uyorum.github.io/blog/infrastructure-as-code-chap3/</link>
      <pubDate>Thu, 15 Jun 2017 23:14:55 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/infrastructure-as-code-chap3/</guid>
      <description>オライリーの「Infrastructure as Code」を読んで思ったことや自分的メモをまとめておく．太字は自分の感想， 斜字体は本からの引用 ，そのほかは本の要約など．
ツールの要件  他のツールを連携しやすいこと  コマンドライン引数や環境変数などでの入力，パースしやすい結果出力 設定の外在化  自動実行しやすいこと  冪等性など 失敗したらわかる  周辺のツールとの連携しやすさは意識して考慮に入れてなかった 考え方はすごくよくわかる．UNIX哲学に通じている  構成レジストリ  コンフィグ定義ツールが提供するもの(Chef Server, Ansible Towerなど) Zookeeper/Consul/etcd プログラムによるレジストリエントリの追加，更新，削除をサポートしていること こういうのほしいと前から思っていたけどどうやって実装すればいいか，定義ツールとどう連携させればいいかイメージついてない  軽い構成レジストリ  S3やVCS上のファイル  HTTP等で配布．こうすることで可用性，スケーリングしやすい．管理が単純 頻繁に更新されて複雑になる部分は分割やシャーディングで対応する  こうした場合，例えばAnsibleへはどうやって渡せばいいんだろうか  ansible-playbook実行前にyaml組んでvar_fileなどに渡す  ダイナミックインベントリみたいなことはできなさそう．一回ファイルに吐き出す必要がある？  json組み立ててansible-playbookの--extra-varsオプションに渡す Ansible TowerのAPIでも渡せるかも  Consumer Driven Contract Testing  Itamaeのnode.validate!はまさにこれだと思う1 こんな記事出てきた Consumer-Driven Contracts: A Service Evolution Pattern Pactのようなツールで容易に書けそう   CMDB  CMDBとInfrastructure as Codeは構成管理に対するアプローチが正反対．両者を同一視してはならない  ただしすべてを自動化するならInfrastructure as CodeはCMDBを兼ねることができる．またはInfrastructure as CodeがCMDBも管理することができる ハードウェアも含めてすべてを自動化はけっこうハードル高そう   その他  インフラを完全に管理，自動化するために，やり方を変えるだけでなく自動化しやすいようにタスクそのものを見直すメンタルを忘れてはいけない  以上</description>
    </item>
    
    <item>
      <title>Infrastructure as Code 感想 (2章)</title>
      <link>http://uyorum.github.io/blog/infrastructure-as-code-chap2/</link>
      <pubDate>Mon, 12 Jun 2017 20:48:25 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/infrastructure-as-code-chap2/</guid>
      <description> オライリーの「Infrastructure as Code」を読んで思ったことや自分的メモをまとめておく．太字は自分の感想， 斜字体は本からの引用 ，そのほかは本の要約など．
ダイナミックインフラストラクチャの要件  NISTのクラウドの要件より広い．  「オンプレミスで，ただひとつのシステムを稼動させるためのインフラ」も考慮に入れているからだろう   プラットフォームから提供されるリソース  計算リソース ストレージリソース  ブロックストレージ オブジェクトストレージ ネットワーク化されたファイルシステム  NFS，SMB  これらのテクノロジは，サーバーが頻繁に追加，削除されるような環境にはうまく適合しない  GlusterFS，HDFS，Ceph  上記の課題に対応できるよう設計されているが，自分の環境でそれがうまくいっていることをきちんとテストすることが重要 代わりにアプリケーションレベルやブロックレベルのレプリケーションで事足りる場合もある    ネットワークリソース  特定のデバイスが高価過ぎて，チームがテストインスタンスを確保できない場合がある．そのような状況に置かれたチームは，優先順位を考えてもっと安いデバイスを使うようにすべきだ  確かに，結局のところ同じハードを同じだけ用意しないとテストできないのだが，そのために使うデバイスを安いものにしろ，という言説は初めて見た．だいたいは仮想化してお茶を濁すのに．    独自クラウドを構築するためのトータルコスト  既存のインフラ，データセンター，知識にかけたコストも自前のホスティングを続ける理由としてよく挙げられる．(中略) しかし，これはサンクコストの呪縛というものだ．  クラウドのポータビリティ  クラウドインフラへの移行を計画するときによく浮上する要件のひとつに，ひとつのクラウドベンダーによる囲い込みを避けるというものがある．(中略) しかし，この要件に時間と金を注ぎ込みすぎないよう注意しなければならない  確かに，クラウドの一部の機能をサードパーティ製のツールで置き換えたところで依然として移行のコストは大きいし，だいたいの場合は運用のコストが上がる あるクラウドでのやり方が(将来にわたって)それが別のクラウドでそのまま利用できるとは限らない  例えば，TerraformでEC2とGCEにインスタンスを作るだけで全く文法が違う(Terraformの批判をしているわけではない) クラウドやツールが将来仕様変更をするかもしれないし  サードパーティ製のものを使うことでよりよりワークフローを得られる可能性がある場合は検討すべき(CodeCommitとCodeBuildの代わりにGithubとTravisCIとか)  自動テストプロセスを継続して維持・使用することで，自信をもって移行を実施できるようにしておくのが現実的な方策  クラウドと仮想マシンに対するマシンレベルの共感  そのプラットフォームで最大のパフォーマンスを引き出すための話？ 必要性は分かるが，ポータビリティとは真逆の話に見える  あまりにそのクラウドに最適化してしまうとポータビリティを落とす要因になりそう  オンプレの場合でも，構成に応じて最適化しつつそれらを管理するのは大変そう．妥協して汎用的なサーバーを横に並べる形になりそう  参考文献  Kief Morris, Infrastructure as Code クラウドにおけるサーバ管理の原則とプラクティス, 長尾高弘訳, オライリー・ジャパン, 2017  </description>
    </item>
    
    <item>
      <title>Infrastructure as Code 感想 (2章)</title>
      <link>http://uyorum.github.io/blog/infrastructure-as-code-chap2/</link>
      <pubDate>Mon, 12 Jun 2017 20:48:25 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/infrastructure-as-code-chap2/</guid>
      <description> オライリーの「Infrastructure as Code」を読んで思ったことや自分的メモをまとめておく．太字は自分の感想， 斜字体は本からの引用 ，そのほかは本の要約など．
ダイナミックインフラストラクチャの要件  NISTのクラウドの要件より広い．  「オンプレミスで，ただひとつのシステムを稼動させるためのインフラ」も考慮に入れているからだろう   プラットフォームから提供されるリソース  計算リソース ストレージリソース  ブロックストレージ オブジェクトストレージ ネットワーク化されたファイルシステム  NFS，SMB  これらのテクノロジは，サーバーが頻繁に追加，削除されるような環境にはうまく適合しない  GlusterFS，HDFS，Ceph  上記の課題に対応できるよう設計されているが，自分の環境でそれがうまくいっていることをきちんとテストすることが重要 代わりにアプリケーションレベルやブロックレベルのレプリケーションで事足りる場合もある    ネットワークリソース  特定のデバイスが高価過ぎて，チームがテストインスタンスを確保できない場合がある．そのような状況に置かれたチームは，優先順位を考えてもっと安いデバイスを使うようにすべきだ  確かに，結局のところ同じハードを同じだけ用意しないとテストできないのだが，そのために使うデバイスを安いものにしろ，という言説は初めて見た．だいたいは仮想化してお茶を濁すのに．    独自クラウドを構築するためのトータルコスト  既存のインフラ，データセンター，知識にかけたコストも自前のホスティングを続ける理由としてよく挙げられる．(中略) しかし，これはサンクコストの呪縛というものだ．  クラウドのポータビリティ  クラウドインフラへの移行を計画するときによく浮上する要件のひとつに，ひとつのクラウドベンダーによる囲い込みを避けるというものがある．(中略) しかし，この要件に時間と金を注ぎ込みすぎないよう注意しなければならない  確かに，クラウドの一部の機能をサードパーティ製のツールで置き換えたところで依然として移行のコストは大きいし，だいたいの場合は運用のコストが上がる あるクラウドでのやり方が(将来にわたって)それが別のクラウドでそのまま利用できるとは限らない  例えば，TerraformでEC2とGCEにインスタンスを作るだけで全く文法が違う(Terraformの批判をしているわけではない) クラウドやツールが将来仕様変更をするかもしれないし  サードパーティ製のものを使うことでよりよりワークフローを得られる可能性がある場合は検討すべき(CodeCommitとCodeBuildの代わりにGithubとTravisCIとか)  自動テストプロセスを継続して維持・使用することで，自信をもって移行を実施できるようにしておくのが現実的な方策  クラウドと仮想マシンに対するマシンレベルの共感  そのプラットフォームで最大のパフォーマンスを引き出すための話？ 必要性は分かるが，ポータビリティとは真逆の話に見える  あまりにそのクラウドに最適化してしまうとポータビリティを落とす要因になりそう  オンプレの場合でも，構成に応じて最適化しつつそれらを管理するのは大変そう．妥協して汎用的なサーバーを横に並べる形になりそう  参考文献  Kief Morris, Infrastructure as Code クラウドにおけるサーバ管理の原則とプラクティス, 長尾高弘訳, オライリー・ジャパン, 2017  </description>
    </item>
    
    <item>
      <title>Infrastructure as Code 感想 (1章)</title>
      <link>http://uyorum.github.io/blog/infrastructure-as-code-chap1/</link>
      <pubDate>Sun, 11 Jun 2017 19:05:42 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/infrastructure-as-code-chap1/</guid>
      <description> オライリーの「Infrastructure as Code」を読んで思ったことや自分的メモをまとめておく．太字は自分の感想， 斜字体は本からの引用 ，そのほかは本の要約など．
Infrastructure as Codeの目標  ざっくり言うと「(頻繁な)変化に柔軟に対応できるようになること」ということかなと思った そのために  システム変更が日常茶飯事の出来事になること 失敗を完全に防ぐという前提は捨てる．失敗しても素早く修正できるようになることを目指す 反復的なタスクは自動化すること 継続的な改善をすること  会議やドキュメントでソリューションを論ずることなく，実装，テスト，計測を通じてソリューションの効果が証明できるようになること  Infrastructure as Codeでこれを目指す，というのがピンと来なかった   課題  サーバースプロール，構成ドリフト，スノーフレークサーバーは自分の環境ではほとんどないかな  いちおうChefを使っている ロールごとにVMを作成して役割が混ざらないようにしている  オートメーション恐怖症…これはある  サーバーに統一性がない→オートメーションにより何かが壊れないかが心配→オートメーションツールの外で変更を加える→… の悪循環 この循環から抜けるには「自動化された変更」のリリースプロセスの確立とテストの充実が必要になると最近は考えている  「この変更」を「この方法」で適用するのは安全である，と自動的に言えるようになればいい   ペットから家畜へ  数年前からよく聞くようになった サーバ名にテーマを設け，自分がプロビジョニングした新しいサーバーの名前をじっくり考えていた時代が懐しい．しかし，担当するすべてのサーバーを手作業で調整し，サーバーのご期限をうかがわなけれあならなかった時代は懐しくない  おもしろい    統一的なシステム  一部のサーバーでより大きなディスクが必要になった場合  すべてのサーバーを同じように拡張する xl-file-serverのような新しいロールを追加する  自分だと深く考えずに(ロールを分けずに)そのサーバーだけ拡張してしまいそうだと思った(ディスクサイズだけ変数化しておけばいいじゃん)  その些細な差異が積み重なって管理システムと人に負荷を与えることになる．気をつけたい   反復的なシステム  「パーティションの分割」のような些細なタスクであろうとも，手動でやってしまうと差異が生じる可能性がある．  サイズ，ファイルシステム，そのパラメータ etc.  スクリプトで実行できるシステムはかならずスクリプトにする  そして，将来同様のタスクをするとになったときにそのスクリプトを使う ←これが難しい．スクリプトを書くだけでなく管理システムに組み込まなければならない  スクリプトにするのが難しい場合は問題を掘り下げて，役に立つテクニックやツールがないか，別の方法がないかを検討する  継続的にサービスを利用可能状態に保つ  永続化が必要なデータの定義を広げることが大切．通常はアプリケーションの構成/設定，ログファイルなども保護対象に含める  サーバーを家畜のように扱うことを前提に，サーバー上のほとんどの情報はいつ失われてもよい状態にしておくということか   参考文献  Kief Morris, Infrastructure as Code クラウドにおけるサーバ管理の原則とプラクティス, 長尾高弘訳, オライリー・ジャパン, 2017  </description>
    </item>
    
    <item>
      <title>Infrastructure as Code 感想 (1章)</title>
      <link>http://uyorum.github.io/blog/infrastructure-as-code-chap1/</link>
      <pubDate>Sun, 11 Jun 2017 19:05:42 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/infrastructure-as-code-chap1/</guid>
      <description> オライリーの「Infrastructure as Code」を読んで思ったことや自分的メモをまとめておく．太字は自分の感想， 斜字体は本からの引用 ，そのほかは本の要約など．
Infrastructure as Codeの目標  ざっくり言うと「(頻繁な)変化に柔軟に対応できるようになること」ということかなと思った そのために  システム変更が日常茶飯事の出来事になること 失敗を完全に防ぐという前提は捨てる．失敗しても素早く修正できるようになることを目指す 反復的なタスクは自動化すること 継続的な改善をすること  会議やドキュメントでソリューションを論ずることなく，実装，テスト，計測を通じてソリューションの効果が証明できるようになること  Infrastructure as Codeでこれを目指す，というのがピンと来なかった   課題  サーバースプロール，構成ドリフト，スノーフレークサーバーは自分の環境ではほとんどないかな  いちおうChefを使っている ロールごとにVMを作成して役割が混ざらないようにしている  オートメーション恐怖症…これはある  サーバーに統一性がない→オートメーションにより何かが壊れないかが心配→オートメーションツールの外で変更を加える→… の悪循環 この循環から抜けるには「自動化された変更」のリリースプロセスの確立とテストの充実が必要になると最近は考えている  「この変更」を「この方法」で適用するのは安全である，と自動的に言えるようになればいい   ペットから家畜へ  数年前からよく聞くようになった サーバ名にテーマを設け，自分がプロビジョニングした新しいサーバーの名前をじっくり考えていた時代が懐しい．しかし，担当するすべてのサーバーを手作業で調整し，サーバーのご期限をうかがわなけれあならなかった時代は懐しくない  おもしろい    統一的なシステム  一部のサーバーでより大きなディスクが必要になった場合  すべてのサーバーを同じように拡張する xl-file-serverのような新しいロールを追加する  自分だと深く考えずに(ロールを分けずに)そのサーバーだけ拡張してしまいそうだと思った(ディスクサイズだけ変数化しておけばいいじゃん)  その些細な差異が積み重なって管理システムと人に負荷を与えることになる．気をつけたい   反復的なシステム  「パーティションの分割」のような些細なタスクであろうとも，手動でやってしまうと差異が生じる可能性がある．  サイズ，ファイルシステム，そのパラメータ etc.  スクリプトで実行できるシステムはかならずスクリプトにする  そして，将来同様のタスクをするとになったときにそのスクリプトを使う ←これが難しい．スクリプトを書くだけでなく管理システムに組み込まなければならない  スクリプトにするのが難しい場合は問題を掘り下げて，役に立つテクニックやツールがないか，別の方法がないかを検討する  継続的にサービスを利用可能状態に保つ  永続化が必要なデータの定義を広げることが大切．通常はアプリケーションの構成/設定，ログファイルなども保護対象に含める  サーバーを家畜のように扱うことを前提に，サーバー上のほとんどの情報はいつ失われてもよい状態にしておくということか   参考文献  Kief Morris, Infrastructure as Code クラウドにおけるサーバ管理の原則とプラクティス, 長尾高弘訳, オライリー・ジャパン, 2017  </description>
    </item>
    
    <item>
      <title>Home AssistantとAmazon Dash Buttonを連携させる</title>
      <link>http://uyorum.github.io/blog/home-assistant-with-dash-button/</link>
      <pubDate>Sat, 10 Jun 2017 20:20:04 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/home-assistant-with-dash-button/</guid>
      <description>&lt;p&gt;Amazon Dash Button間違った使い方ができることで有名だが，Amazon Dash ButtonからHome Assistantでアクションをキックできるようにしてみる．&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Home AssistantとAmazon Dash Buttonを連携させる</title>
      <link>http://uyorum.github.io/blog/home-assistant-with-dash-button/</link>
      <pubDate>Sat, 10 Jun 2017 20:20:04 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/home-assistant-with-dash-button/</guid>
      <description>&lt;p&gt;Amazon Dash Button間違った使い方ができることで有名だが，Amazon Dash ButtonからHome Assistantでアクションをキックできるようにしてみる．&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Home Assistantで人感センサーを使って照明を自動点灯する</title>
      <link>http://uyorum.github.io/blog/home-assistant-gpio/</link>
      <pubDate>Sun, 23 Apr 2017 21:33:54 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/home-assistant-gpio/</guid>
      <description>&lt;p&gt;Home Assistantで人感センサーを使って自宅の廊下の電球を点灯/消灯するシステムを組んでみる．&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Home Assistantで人感センサーを使って照明を自動点灯する</title>
      <link>http://uyorum.github.io/blog/home-assistant-gpio/</link>
      <pubDate>Sun, 23 Apr 2017 21:33:54 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/home-assistant-gpio/</guid>
      <description>&lt;p&gt;Home Assistantで人感センサーを使って自宅の廊下の電球を点灯/消灯するシステムを組んでみる．&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Home Assistantでつくるホームオートメーション(導入編)</title>
      <link>http://uyorum.github.io/blog/home-assistant-install/</link>
      <pubDate>Sat, 22 Apr 2017 21:48:00 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/home-assistant-install/</guid>
      <description>&lt;p&gt;ホームオートメーション/スマートホーム化を実現できるOSSのHome Asssitantについて&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Home Assistantでつくるホームオートメーション(導入編)</title>
      <link>http://uyorum.github.io/blog/home-assistant-install/</link>
      <pubDate>Sat, 22 Apr 2017 21:48:00 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/home-assistant-install/</guid>
      <description>&lt;p&gt;ホームオートメーション/スマートホーム化を実現できるOSSのHome Asssitantについて&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Erato Audio Apollo7 レビュー</title>
      <link>http://uyorum.github.io/blog/apollo7-1/</link>
      <pubDate>Sun, 09 Oct 2016 17:39:14 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/apollo7-1/</guid>
      <description>Erato Audio社の完全ワイヤレスイヤホンApollo7を買って1週間ほど使ったので使用感とかレビューを書いておきます．
なぜ今買ったか 完全ワイヤレスイヤホンという分野を知ったのは2014年にKickstarterでEARINが発表されたときでした． そのときは非常に気になっていたのですが，スペック的にいくつか気になるところもあり，まだ新しい分野でもあったので買うのはもう少し製品が成熟してからにしようと思って手を出しませんでした． 以降はこの分野については特にウォッチはせずに忘れていたのですが，最近AppleからAirPodsが発表されたのを見て思い出して再度調べてみたのがきっかけでした． いくつかのメーカーから同様の製品が発売されていることを知り，その中でよさそうなApolloo7を選択しました．
なぜApollo7を選択したか とりあえず2ちゃんねるの該当スレで評判を見ていきました． ざっと眺めたところ，スレ内ではEARIN，Apollo7，The Dashがよく話題に挙がる機種のようでした． 各機種の特徴と評判は以下の通り．
EARIN  BA型ドライバを搭載 人の多いところで接続が切れやすいという発言をよく見かけた そもそもかつて見送った機種  The Dash  ストレージ内蔵，フィットネストラッカー搭載，トランスペアレントモード搭載と，他の機種と比べて多機能  個人的には前半2つの機能はこの手の機種に求めない  本体とケースが大きい  Apollo7  人が多いところでも接続が切れにくいという発言をよく見かけた 自分が求めている必要最小限の機能 デザインがよい 9/30に国内代理店が取扱いを開始するので保証などを受けやすい  以上の点から検討した結果，Apollo7を選択しました． 国内だとeイヤホンで試聴できるですが，所詮Bluetoothだし音質はそれほど重視していなかったので試聴せずにヨドバシドットコムにて購入．
使い勝手 各イヤホンは本体にボタンを搭載しており，このボタンを押すことで本体またはスマホを操作します． 各イヤホンにはLまたはRと印字されており，左右どちら用かはあらかじめ決まっているようです．
初期セットアップ  左右どちらかのイヤホン(以降，右耳とする)のボタンを長押しする 「Power on」と声が流れるが引き続き長押しし続ける 「Pairing」と声が流れるのでスマホを操作しペアリングする 「Phone connected」と声が流れる(このイヤホンがスマホと接続される) 左耳のイヤホンのボタンを長押しする 「Headset connected」と両耳から流れる(このイヤホンは右耳のイヤホンと接続される)  再度使うとき  イヤホンをケースから取り出す 右耳のイヤホンのボタンを長押しする(「Power on」と流れる) しばらくするとスマホと接続される(「Phone connected」と流れる) 左耳のイヤホンのボタンを長押しする(「Power on」と流れる) しばらくすると右耳と接続される(「Headset connected」と両耳から流れる)  レビュー いずれもNexus5で使用していて気付いた点です．ペアリングする機種によって接続の切れにくさなどは異なる可能性があります．
いい点  やっぱり完全ワイヤレスは便利
鞄の中でケーブルがからまることがない，使用中にケーブルがひっかかることがない．かなり便利です． フィット感がいい</description>
    </item>
    
    <item>
      <title>Erato Audio Apollo7 レビュー</title>
      <link>http://uyorum.github.io/blog/apollo7-1/</link>
      <pubDate>Sun, 09 Oct 2016 17:39:14 +0900</pubDate>
      
      <guid>http://uyorum.github.io/blog/apollo7-1/</guid>
      <description>Erato Audio社の完全ワイヤレスイヤホンApollo7を買って1週間ほど使ったので使用感とかレビューを書いておきます．
なぜ今買ったか 完全ワイヤレスイヤホンという分野を知ったのは2014年にKickstarterでEARINが発表されたときでした． そのときは非常に気になっていたのですが，スペック的にいくつか気になるところもあり，まだ新しい分野でもあったので買うのはもう少し製品が成熟してからにしようと思って手を出しませんでした． 以降はこの分野については特にウォッチはせずに忘れていたのですが，最近AppleからAirPodsが発表されたのを見て思い出して再度調べてみたのがきっかけでした． いくつかのメーカーから同様の製品が発売されていることを知り，その中でよさそうなApolloo7を選択しました．
なぜApollo7を選択したか とりあえず2ちゃんねるの該当スレで評判を見ていきました． ざっと眺めたところ，スレ内ではEARIN，Apollo7，The Dashがよく話題に挙がる機種のようでした． 各機種の特徴と評判は以下の通り．
EARIN  BA型ドライバを搭載 人の多いところで接続が切れやすいという発言をよく見かけた そもそもかつて見送った機種  The Dash  ストレージ内蔵，フィットネストラッカー搭載，トランスペアレントモード搭載と，他の機種と比べて多機能  個人的には前半2つの機能はこの手の機種に求めない  本体とケースが大きい  Apollo7  人が多いところでも接続が切れにくいという発言をよく見かけた 自分が求めている必要最小限の機能 デザインがよい 9/30に国内代理店が取扱いを開始するので保証などを受けやすい  以上の点から検討した結果，Apollo7を選択しました． 国内だとeイヤホンで試聴できるですが，所詮Bluetoothだし音質はそれほど重視していなかったので試聴せずにヨドバシドットコムにて購入．
使い勝手 各イヤホンは本体にボタンを搭載しており，このボタンを押すことで本体またはスマホを操作します． 各イヤホンにはLまたはRと印字されており，左右どちら用かはあらかじめ決まっているようです．
初期セットアップ  左右どちらかのイヤホン(以降，右耳とする)のボタンを長押しする 「Power on」と声が流れるが引き続き長押しし続ける 「Pairing」と声が流れるのでスマホを操作しペアリングする 「Phone connected」と声が流れる(このイヤホンがスマホと接続される) 左耳のイヤホンのボタンを長押しする 「Headset connected」と両耳から流れる(このイヤホンは右耳のイヤホンと接続される)  再度使うとき  イヤホンをケースから取り出す 右耳のイヤホンのボタンを長押しする(「Power on」と流れる) しばらくするとスマホと接続される(「Phone connected」と流れる) 左耳のイヤホンのボタンを長押しする(「Power on」と流れる) しばらくすると右耳と接続される(「Headset connected」と両耳から流れる)  レビュー いずれもNexus5で使用していて気付いた点です．ペアリングする機種によって接続の切れにくさなどは異なる可能性があります．
いい点  やっぱり完全ワイヤレスは便利
鞄の中でケーブルがからまることがない，使用中にケーブルがひっかかることがない．かなり便利です． フィット感がいい</description>
    </item>
    
  </channel>
</rss>